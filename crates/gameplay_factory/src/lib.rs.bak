//! Unified entity factory for prefab-based gameplay systems
//!
//! This crate provides a factory pattern for creating game entities from prefab definitions.
//! It supports loading prefabs from various sources and spawning them into the ECS world.
//!
//! # Architecture
//!
//! The factory system follows a two-stage approach:
//! 1. **Registration Phase**: Prefabs are loaded from sources and registered with unique IDs
//! 2. **Spawning Phase**: Entities are spawned from registered prefabs into the ECS world
//!
//! # Core Components
//!
//! - [`Factory`]: Main factory for prefab registry and spawning
//! - [`Prefab`]: Prefab definition with component initializers
//! - [`PrefabSource`]: Trait for loading prefabs from various sources
//! - [`ComponentInit`]: Trait for component initialization
//! - [`RonLoader`]: RON-based prefab loader (feature-gated)
//!
//! # Basic Usage
//!
//! ```rust
//! use gameplay_factory::{Factory, Prefab, PrefabId};
//! use bevy_ecs::system::Commands;
//!
//! // Create a factory
//! let mut factory = Factory::new();
//!
//! // Register a prefab
//! let prefab = Prefab::new(); // Add components as needed
//! factory.register(PrefabId::from(1u32), prefab);
//!
//! // Spawn entities (requires ECS Commands)
//! // factory.spawn(&mut commands, PrefabId::from(1u32))?;
//! ```
//!
//! # RON Integration
//!
//! With the `ron` feature enabled, you can load prefabs from RON files:
//!
//! ```rust
//! #[cfg(feature = "ron")]
//! use gameplay_factory::{Factory, RonLoader, PrefabId};
//!
//! #[cfg(feature = "ron")]
//! {
//!     let mut factory = Factory::new();
//!     let ron_content = r#"
//!         RonPrefab(
//!             components: [
//!                 RonComponent(
//!                     component_type: "Health",
//!                     data: Number(100.0)
//!                 )
//!             ]
//!         )
//!     "#;
//!     let loader = RonLoader::new(ron_content.to_string());
//!     factory.load_from_source(PrefabId::from(1u32), &loader)?;
//! }
//! # Ok::<(), gameplay_factory::Error>(())
//! ```
//!
//! # RON File Format
//!
//! RON prefab files use this structure:
//!
//! ```ron
//! RonPrefab(
//!     components: [
//!         RonComponent(
//!             component_type: "Transform",
//!             data: Map({
//!                 "translation": Map({"x": 0.0, "y": 0.0, "z": 0.0}),
//!                 "rotation": Map({"x": 0.0, "y": 0.0, "z": 0.0, "w": 1.0}),
//!                 "scale": Map({"x": 1.0, "y": 1.0, "z": 1.0})
//!             })
//!         ),
//!         RonComponent(
//!             component_type: "Health",
//!             data: Number(100.0)
//!         )
//!     ]
//! )
//! ```
//!
//! # Performance Considerations
//!
//! - **Prefab Registry**: HashMap with O(1) lookup by PrefabId
//! - **Component Storage**: `Vec<Box<dyn ComponentInit>>` for type erasure
//! - **Spawn Time**: O(n) where n is number of components in prefab
//! - **Memory**: Prefabs are stored once and reused for multiple spawns
//!
//! # Error Handling
//!
//! All operations return `Result<T, Error>` where `Error` provides detailed
//! information about resource loading, serialization, and validation failures.
//!
//! # Features
//!
//! - `ron`: Enable RON file format support for prefab loading

use bevy_ecs::system::Commands;
use std::collections::HashMap;

pub use amp_core::Error;

/// Component registry for RON deserialization
pub type ComponentRegistry = HashMap<&'static str, Box<dyn Fn(&ron::Value, &mut Commands, bevy_ecs::entity::Entity) -> Result<(), Error> + Send + Sync>>;

/// Global component registry instance
static mut COMPONENT_REGISTRY: Option<ComponentRegistry> = None;

/// Initialize the component registry with basic Bevy components
pub fn init_component_registry() {
    let mut registry = ComponentRegistry::new();
    
    // Register basic Bevy components
    registry.insert("Transform", Box::new(|value, cmd, entity| {
        use bevy_transform::prelude::Transform;
        
        let transform = match value {
            ron::Value::Map(map) => {
                let mut transform = Transform::default();
                
                // Parse translation
                if let Some(translation) = map.get("translation") {
                    if let ron::Value::Map(trans_map) = translation {
                        let x = trans_map.get("x")
                            .and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        let y = trans_map.get("y")
                            .and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        let z = trans_map.get("z")
                            .and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        transform.translation = bevy_math::Vec3::new(x, y, z);
                    }
                }
                
                // Parse rotation (quaternion)
                if let Some(rotation) = map.get("rotation") {
                    if let ron::Value::Map(rot_map) = rotation {
                        let x = rot_map.get("x")
                            .and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        let y = rot_map.get("y")
                            .and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        let z = rot_map.get("z")
                            .and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        let w = rot_map.get("w")
                            .and_then(|v| v.as_f64()).unwrap_or(1.0) as f32;
                        transform.rotation = bevy_math::Quat::from_xyzw(x, y, z, w);
                    }
                }
                
                // Parse scale
                if let Some(scale) = map.get("scale") {
                    if let ron::Value::Map(scale_map) = scale {
                        let x = scale_map.get("x")
                            .and_then(|v| v.as_f64()).unwrap_or(1.0) as f32;
                        let y = scale_map.get("y")
                            .and_then(|v| v.as_f64()).unwrap_or(1.0) as f32;
                        let z = scale_map.get("z")
                            .and_then(|v| v.as_f64()).unwrap_or(1.0) as f32;
                        transform.scale = bevy_math::Vec3::new(x, y, z);
                    }
                }
                
                transform
            }
            _ => Transform::default(),
        };
        
        cmd.entity(entity).insert(transform);
        Ok(())
    }));
    
    registry.insert("Name", Box::new(|value, cmd, entity| {
        use bevy_core::prelude::Name;
        
        let name = match value {
            ron::Value::String(s) => Name::new(s.clone()),
            _ => Name::new("Unnamed"),
        };
        
        cmd.entity(entity).insert(name);
        Ok(())
    }));
    
    registry.insert("Visibility", Box::new(|value, cmd, entity| {
        use bevy_render::prelude::Visibility;
        
        let visibility = match value {
            ron::Value::String(s) => match s.as_str() {
                "Hidden" => Visibility::Hidden,
                "Visible" => Visibility::Visible,
                "Inherited" => Visibility::Inherited,
                _ => Visibility::Inherited,
            },
            _ => Visibility::Inherited,
        };
        
        cmd.entity(entity).insert(visibility);
        Ok(())
    }));
    
    unsafe {
        COMPONENT_REGISTRY = Some(registry);
    }
}

/// Get the component registry
pub fn get_component_registry() -> Option<&'static ComponentRegistry> {
    unsafe { COMPONENT_REGISTRY.as_ref() }
}

/// Register a custom component deserializer
pub fn register_component<F>(name: &'static str, deserializer: F) 
where
    F: Fn(&ron::Value, &mut Commands, bevy_ecs::entity::Entity) -> Result<(), Error> + Send + Sync + 'static,
{
    unsafe {
        if COMPONENT_REGISTRY.is_none() {
            init_component_registry();
        }
        if let Some(registry) = COMPONENT_REGISTRY.as_mut() {
            registry.insert(name, Box::new(deserializer));
        }
    }
}

mod prefab;
pub use prefab::*;

#[cfg(feature = "ron")]
mod ron_loader;
#[cfg(feature = "ron")]
pub use ron_loader::*;

/// Unique identifier for prefab definitions
///
/// PrefabId is a lightweight wrapper around a u64 that provides type safety
/// for prefab identification. It implements Hash and Eq for use in HashMap
/// collections and supports conversion from u64 for convenience.
///
/// # Examples
///
/// ```rust
/// use gameplay_factory::PrefabId;
///
/// let id = PrefabId::from(42u64);
/// assert_eq!(id.0, 42);
///
/// // Can be used as HashMap keys
/// use std::collections::HashMap;
/// let mut map = HashMap::new();
/// map.insert(id, "some_prefab_data");
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct PrefabId(pub u64);

impl From<u64> for PrefabId {
    fn from(id: u64) -> Self {
        Self(id)
    }
}

impl From<u32> for PrefabId {
    fn from(id: u32) -> Self {
        Self(id as u64)
    }
}

/// Trait for loading prefab definitions from various sources
///
/// PrefabSource provides a unified interface for loading prefabs from different
/// sources such as files, databases, or network endpoints. Implementations
/// handle the specifics of data loading and parsing.
///
/// # Examples
///
/// ```rust
/// use gameplay_factory::{PrefabSource, Prefab, Error};
///
/// struct StringSource {
///     content: String,
/// }
///
/// impl PrefabSource for StringSource {
///     fn load(&self) -> Result<Prefab, Error> {
///         // Parse content and create prefab
///         Ok(Prefab::new())
///     }
/// }
/// ```
pub trait PrefabSource {
    /// Load a prefab from this source
    ///
    /// This method should handle all aspects of loading and parsing the prefab
    /// data, returning a fully constructed Prefab or an Error if loading fails.
    fn load(&self) -> Result<Prefab, Error>;
}

/// Factory for creating entities from prefab definitions
///
/// The Factory maintains a registry of prefabs indexed by PrefabId and provides
/// methods for registering new prefabs and spawning entities from them. It uses
/// a HashMap for O(1) lookup performance and supports loading prefabs from
/// various sources.
///
/// # Examples
///
/// ```rust
/// use gameplay_factory::{Factory, Prefab, PrefabId};
///
/// let mut factory = Factory::new();
/// let prefab = Prefab::new();
/// let id = PrefabId::from(1u32);
///
/// // Register a prefab
/// factory.register(id, prefab);
///
/// // Check if registered
/// assert!(factory.contains(id));
/// assert_eq!(factory.len(), 1);
/// ```
pub struct Factory {
    registry: HashMap<PrefabId, Prefab>,
}

impl Factory {
    /// Create a new empty factory
    pub fn new() -> Self {
        Self {
            registry: HashMap::new(),
        }
    }

    /// Register a prefab with the factory
    ///
    /// Stores the prefab in the factory's registry with the given ID. If a prefab
    /// with the same ID already exists, it will be replaced.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use gameplay_factory::{Factory, Prefab, PrefabId};
    ///
    /// let mut factory = Factory::new();
    /// let prefab = Prefab::new();
    /// factory.register(PrefabId::from(1u32), prefab);
    /// ```
    pub fn register(&mut self, id: PrefabId, prefab: Prefab) {
        // Check for collision detection
        if self.registry.contains_key(&id) {
            log::warn!("Prefab ID {:?} already exists, replacing existing prefab", id);
        }
        self.registry.insert(id, prefab);
    }

    /// Load and register a prefab from a source
    ///
    /// Loads a prefab from the given source and registers it with the specified ID.
    /// This is a convenience method that combines loading and registration in one step.
    ///
    /// # Errors
    ///
    /// Returns an error if the source fails to load the prefab.
    ///
    /// # Examples
    ///
    /// ```rust
    /// use gameplay_factory::{Factory, PrefabSource, Prefab, PrefabId, Error};
    ///
    /// struct TestSource;
    /// impl PrefabSource for TestSource {
    ///     fn load(&self) -> Result<Prefab, Error> {
    ///         Ok(Prefab::new())
    ///     }
    /// }
    ///
    /// let mut factory = Factory::new();
    /// let source = TestSource;
    /// factory.load_from_source(PrefabId::from(1u32), &source).unwrap();
    /// ```
    pub fn load_from_source(
        &mut self,
        id: PrefabId,
        source: &dyn PrefabSource,
    ) -> Result<(), Error> {
        let prefab = source.load()?;
        self.register(id, prefab);
        Ok(())
    }

    /// Spawn an entity from a registered prefab
    ///
    /// Creates a new entity in the ECS world by running all component initializers
    /// from the specified prefab. The prefab must be registered with the factory first.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - The prefab ID is not found in the registry
    /// - Any component initializer fails during entity creation
    ///
    /// # Examples
    ///
    /// ```rust
    /// use gameplay_factory::{Factory, Prefab, PrefabId};
    /// use bevy_ecs::system::{Commands, CommandQueue};
    /// use bevy_ecs::world::World;
    ///
    /// let mut factory = Factory::new();
    /// let prefab = Prefab::new();
    /// factory.register(PrefabId::from(1u32), prefab);
    ///
    /// // Spawn entity (requires ECS setup)
    /// let world = World::new();
    /// let mut queue = CommandQueue::default();
    /// let mut cmd = Commands::new(&mut queue, &world);
    /// let entity = factory.spawn(&mut cmd, PrefabId::from(1u32)).unwrap();
    /// ```
    pub fn spawn(
        &self,
        cmd: &mut Commands,
        id: PrefabId,
    ) -> Result<bevy_ecs::entity::Entity, Error> {
        let prefab = self.registry.get(&id).ok_or_else(|| {
            Error::resource_load(format!("Prefab {id:?}"), "not found in registry")
        })?;

        prefab.spawn(cmd)
    }

    /// Check if a prefab is registered
    pub fn contains(&self, id: PrefabId) -> bool {
        self.registry.contains_key(&id)
    }

    /// Get the number of registered prefabs
    pub fn len(&self) -> usize {
        self.registry.len()
    }

    /// Check if the factory is empty
    pub fn is_empty(&self) -> bool {
        self.registry.is_empty()
    }

    /// Load prefabs from a directory based on factory settings
    ///
    /// This method uses the provided FactorySettings to:
    /// 1. Expand tilde (~) in the prefab_path
    /// 2. Use glob pattern matching to find .ron files
    /// 3. Load each prefab file and register it with an auto-generated ID
    /// 4. Handle hot_reload setting (currently a stub)
    ///
    /// # Arguments
    ///
    /// * `settings` - Configuration settings specifying prefab_path and hot_reload
    ///
    /// # Returns
    ///
    /// Returns the number of prefabs loaded successfully
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Path expansion fails (e.g., home directory not found)
    /// - Glob pattern matching fails
    /// - Directory doesn't exist
    /// - Any prefab file fails to load
    ///
    /// # Examples
    ///
    /// ```rust
    /// use gameplay_factory::Factory;
    /// use config_core::FactorySettings;
    /// use std::fs;
    /// use tempfile::TempDir;
    ///
    /// let temp_dir = TempDir::new().unwrap();
    /// let prefab_dir = temp_dir.path().join("prefabs");
    /// fs::create_dir_all(&prefab_dir).unwrap();
    ///
    /// let mut factory = Factory::new();
    /// let settings = FactorySettings {
    ///     prefab_path: format!("{}/*.ron", prefab_dir.display()),
    ///     hot_reload: false,
    /// };
    ///
    /// let loaded_count = factory.load_directory(&settings)?;
    /// println!("Loaded {} prefabs", loaded_count);
    /// # Ok::<(), amp_core::Error>(())
    /// ```
    #[cfg(feature = "ron")]
    pub fn load_directory(
        &mut self,
        settings: &config_core::FactorySettings,
    ) -> Result<usize, Error> {
        use std::path::Path;

        // Expand tilde in prefab_path
        let expanded_path = settings.expanded_prefab_path()?;

        // Handle hot_reload setting
        if settings.hot_reload {
            self.setup_file_watcher(&expanded_path)?;
        }

        // Use glob to find matching files
        let paths = glob::glob(&expanded_path).map_err(|e| {
            Error::resource_load(
                "glob pattern",
                &format!("Invalid glob pattern '{}': {}", expanded_path, e),
            )
        })?;

        let mut loaded_count = 0;
        let mut errors = Vec::new();

        for path_result in paths {
            match path_result {
                Ok(path) => {
                    // Generate a unique ID based on the filename
                    let prefab_id = self.generate_prefab_id_from_path(&path)?;

                    // Load the prefab file
                    match self.load_prefab_file(&path) {
                        Ok(prefab) => {
                            self.register(prefab_id, prefab);
                            loaded_count += 1;
                            log::debug!("Loaded prefab {:?} from {}", prefab_id, path.display());
                        }
                        Err(e) => {
                            errors.push(format!("Failed to load {}: {}", path.display(), e));
                        }
                    }
                }
                Err(e) => {
                    errors.push(format!("Glob error: {}", e));
                }
            }
        }

        // If we have errors but also loaded some files, log warnings
        if !errors.is_empty() && loaded_count > 0 {
            for error in &errors {
                log::warn!("{}", error);
            }
        }

        // If we have errors and loaded nothing, return the first error
        if !errors.is_empty() && loaded_count == 0 {
            return Err(Error::resource_load("prefab directory", &errors[0]));
        }

        // If no files were found, check if the directory exists
        if loaded_count == 0 {
            let parent_dir = Path::new(&expanded_path)
                .parent()
                .unwrap_or_else(|| Path::new("."));

            if !parent_dir.exists() {
                return Err(Error::resource_load(
                    "prefab directory",
                    &format!("Directory {} does not exist", parent_dir.display()),
                ));
            }

            // Directory exists but no matching files
            log::info!("No .ron files found matching pattern: {}", expanded_path);
        }

        Ok(loaded_count)
    }

    /// Generate a PrefabId from a file path
    ///
    /// This method creates a unique ID based on the full path, using a 64-bit hash
    /// to minimize collision risk.
    #[cfg(feature = "ron")]
    pub fn generate_prefab_id_from_path(&self, path: &std::path::Path) -> Result<PrefabId, Error> {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        // Use the full path for better collision resistance
        let full_path = path
            .to_str()
            .ok_or_else(|| Error::resource_load("filename", "Non-UTF8 path"))?;

        // Create a hash of the full path to ensure uniqueness
        let mut hasher = DefaultHasher::new();
        full_path.hash(&mut hasher);
        let hash = hasher.finish();

        // Check for collision in existing registry
        let id = PrefabId(hash);
        if self.registry.contains_key(&id) {
            return Err(Error::validation(format!(
                "Hash collision detected for path {}: ID {:?} already exists",
                full_path, id
            )));
        }

        Ok(id)
    }

    /// Load a prefab from a RON file
    #[cfg(feature = "ron")]
    fn load_prefab_file(&self, path: &std::path::Path) -> Result<Prefab, Error> {
        let content = std::fs::read_to_string(path).map_err(|e| {
            Error::resource_load(
                &format!("prefab file {}", path.display()),
                &format!("IO error: {}", e),
            )
        })?;

        let loader = crate::RonLoader::new(content);
        loader.load()
    }

    /// Set up file watcher for hot-reload functionality
    #[cfg(feature = "ron")]
    fn setup_file_watcher(&self, _path: &str) -> Result<(), Error> {
        #[cfg(feature = "hot-reload")]
        {
            // TODO: Implement real file watcher with notify crate
            log::info!("Hot-reload file watcher would be set up for path: {}", _path);
            Ok(())
        }
        #[cfg(not(feature = "hot-reload"))]
        {
            log::warn!("Hot-reload requested but hot-reload feature is not enabled");
            Ok(())
        }
    }
}

impl Default for Factory {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bevy_ecs::entity::Entity;
    use bevy_ecs::system::{CommandQueue, Commands};
    use bevy_ecs::world::World;
    use rstest::*;
    use std::any::Any;

    // Test component for testing ComponentInit
    #[derive(Debug, Clone, PartialEq)]
    struct TestComponent {
        value: i32,
    }

    impl ComponentInit for TestComponent {
        fn init(&self, _cmd: &mut Commands, _entity: Entity) -> Result<(), Error> {
            Ok(())
        }

        fn as_any(&self) -> &dyn Any {
            self
        }
    }

    // Test component that fails initialization
    #[derive(Debug, Clone, PartialEq)]
    struct FailingComponent;

    impl ComponentInit for FailingComponent {
        fn init(&self, _cmd: &mut Commands, _entity: Entity) -> Result<(), Error> {
            Err(Error::validation("Component initialization failed"))
        }

        fn as_any(&self) -> &dyn Any {
            self
        }
    }

    // Test prefab source implementation
    struct TestSource {
        prefab: Prefab,
    }

    impl PrefabSource for TestSource {
        fn load(&self) -> Result<Prefab, Error> {
            let mut prefab = Prefab::new();
            for _component in self.prefab.components() {
                prefab.add_component(Box::new(TestComponent { value: 42 }));
            }
            Ok(prefab)
        }
    }

    // Test prefab source that fails
    struct FailingSource;

    impl PrefabSource for FailingSource {
        fn load(&self) -> Result<Prefab, Error> {
            Err(Error::resource_load("test", "Simulated load failure"))
        }
    }

    #[rstest]
    fn test_prefab_id_from_u32() {
        let id = PrefabId::from(42u32);
        assert_eq!(id.0, 42);
    }

    #[rstest]
    fn test_prefab_id_debug() {
        let id = PrefabId::from(123u32);
        let debug_str = format!("{id:?}");
        assert!(debug_str.contains("123"));
    }

    #[rstest]
    fn test_prefab_id_equality() {
        let id1 = PrefabId::from(42u32);
        let id2 = PrefabId::from(42u32);
        let id3 = PrefabId::from(99u32);

        assert_eq!(id1, id2);
        assert_ne!(id1, id3);
    }

    #[rstest]
    fn test_prefab_id_hash() {
        use std::collections::HashSet;
        let mut set = HashSet::new();

        let id1 = PrefabId::from(42u32);
        let id2 = PrefabId::from(42u32);
        let id3 = PrefabId::from(99u32);

        set.insert(id1);
        set.insert(id2);
        set.insert(id3);

        assert_eq!(set.len(), 2); // id1 and id2 are the same
    }

    #[rstest]
    fn test_factory_new() {
        let factory = Factory::new();
        assert!(factory.is_empty());
        assert_eq!(factory.len(), 0);
    }

    #[rstest]
    fn test_factory_register() {
        let mut factory = Factory::new();
        let prefab = Prefab::new();
        let id = PrefabId::from(1u32);

        factory.register(id, prefab);

        assert!(!factory.is_empty());
        assert_eq!(factory.len(), 1);
        assert!(factory.contains(id));
    }

    #[rstest]
    fn test_factory_register_multiple() {
        let mut factory = Factory::new();
        let id1 = PrefabId::from(1u32);
        let id2 = PrefabId::from(2u32);

        factory.register(id1, Prefab::new());
        factory.register(id2, Prefab::new());

        assert_eq!(factory.len(), 2);
        assert!(factory.contains(id1));
        assert!(factory.contains(id2));
    }

    #[rstest]
    fn test_factory_register_overwrite() {
        let mut factory = Factory::new();
        let id = PrefabId::from(1u32);
        let prefab1 = Prefab::new().with_component(Box::new(TestComponent { value: 1 }));
        let prefab2 = Prefab::new().with_component(Box::new(TestComponent { value: 2 }));

        factory.register(id, prefab1);
        factory.register(id, prefab2);

        assert_eq!(factory.len(), 1);
        assert!(factory.contains(id));
    }

    #[rstest]
    fn test_factory_load_from_source() {
        let mut factory = Factory::new();
        let prefab = Prefab::new().with_component(Box::new(TestComponent { value: 42 }));
        let source = TestSource { prefab };
        let id = PrefabId::from(1u32);

        let result = factory.load_from_source(id, &source);

        assert!(result.is_ok());
        assert!(factory.contains(id));
    }

    #[rstest]
    fn test_factory_load_from_source_error() {
        let mut factory = Factory::new();
        let source = FailingSource;
        let id = PrefabId::from(1u32);

        let result = factory.load_from_source(id, &source);

        assert!(result.is_err());
        assert!(!factory.contains(id));
    }

    #[rstest]
    fn test_factory_spawn_success() {
        let mut factory = Factory::new();
        let prefab = Prefab::new().with_component(Box::new(TestComponent { value: 42 }));
        let id = PrefabId::from(1u32);

        factory.register(id, prefab);

        let world = World::new();
        let mut queue = CommandQueue::default();
        let mut cmd = Commands::new(&mut queue, &world);

        let result = factory.spawn(&mut cmd, id);
        assert!(result.is_ok());
        let entity = result.unwrap();
        // Verify we got a valid entity (index can be 0)
        assert_ne!(entity.index(), u32::MAX); // MAX is invalid entity marker
    }

    #[rstest]
    fn test_factory_spawn_not_found() {
        let factory = Factory::new();
        let id = PrefabId::from(999);

        let world = World::new();
        let mut queue = CommandQueue::default();
        let mut cmd = Commands::new(&mut queue, &world);

        let result = factory.spawn(&mut cmd, id);
        assert!(result.is_err());
    }

    #[rstest]
    fn test_factory_spawn_component_error() {
        let mut factory = Factory::new();
        let prefab = Prefab::new().with_component(Box::new(FailingComponent));
        let id = PrefabId::from(1u32);

        factory.register(id, prefab);

        let world = World::new();
        let mut queue = CommandQueue::default();
        let mut cmd = Commands::new(&mut queue, &world);

        let result = factory.spawn(&mut cmd, id);
        assert!(result.is_err());
    }

    #[rstest]
    fn test_prefab_new() {
        let prefab = Prefab::new();
        assert!(prefab.is_empty());
        assert_eq!(prefab.len(), 0);
    }

    #[rstest]
    fn test_prefab_with_component() {
        let prefab = Prefab::new().with_component(Box::new(TestComponent { value: 42 }));
        assert!(!prefab.is_empty());
        assert_eq!(prefab.len(), 1);
    }

    #[rstest]
    fn test_prefab_with_multiple_components() {
        let prefab = Prefab::new()
            .with_component(Box::new(TestComponent { value: 1 }))
            .with_component(Box::new(TestComponent { value: 2 }));
        assert_eq!(prefab.len(), 2);
    }

    #[rstest]
    fn test_prefab_add_component() {
        let mut prefab = Prefab::new();
        prefab.add_component(Box::new(TestComponent { value: 42 }));
        assert_eq!(prefab.len(), 1);
    }

    #[rstest]
    fn test_prefab_spawn() {
        let prefab = Prefab::new().with_component(Box::new(TestComponent { value: 42 }));

        let world = World::new();
        let mut queue = CommandQueue::default();
        let mut cmd = Commands::new(&mut queue, &world);

        let result = prefab.spawn(&mut cmd);
        assert!(result.is_ok());
        let entity = result.unwrap();
        // Verify we got a valid entity (index can be 0)
        assert_ne!(entity.index(), u32::MAX); // MAX is invalid entity marker
    }

    #[rstest]
    fn test_prefab_spawn_empty() {
        let prefab = Prefab::new();

        let world = World::new();
        let mut queue = CommandQueue::default();
        let mut cmd = Commands::new(&mut queue, &world);

        let result = prefab.spawn(&mut cmd);
        assert!(result.is_ok());
        let entity = result.unwrap();
        // Verify we got a valid entity (index can be 0)
        assert_ne!(entity.index(), u32::MAX); // MAX is invalid entity marker
    }

    #[rstest]
    fn test_prefab_spawn_with_failing_component() {
        let prefab = Prefab::new().with_component(Box::new(FailingComponent));

        let world = World::new();
        let mut queue = CommandQueue::default();
        let mut cmd = Commands::new(&mut queue, &world);

        let result = prefab.spawn(&mut cmd);
        assert!(result.is_err());
        // Entity should be despawned on failure, so no entity returned
    }

    #[rstest]
    fn test_factory_default() {
        let factory = Factory::default();
        assert!(factory.is_empty());
        assert_eq!(factory.len(), 0);
    }

    #[rstest]
    fn test_prefab_default() {
        let prefab = Prefab::default();
        assert!(prefab.is_empty());
        assert_eq!(prefab.len(), 0);
    }

    #[rstest]
    fn test_component_init_as_any() {
        let component = TestComponent { value: 42 };
        let any_ref = component.as_any();

        let downcasted = any_ref.downcast_ref::<TestComponent>();
        assert!(downcasted.is_some());
        assert_eq!(downcasted.unwrap().value, 42);
    }

    #[rstest]
    fn test_failing_component_as_any() {
        let component = FailingComponent;
        let any_ref = component.as_any();

        let downcasted = any_ref.downcast_ref::<FailingComponent>();
        assert!(downcasted.is_some());
    }

    #[cfg(feature = "ron")]
    mod directory_loading_tests {
        use super::*;
        use config_core::FactorySettings;
        use std::fs;
        use tempfile::TempDir;

        #[rstest]
        fn test_load_directory_success() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs");
            fs::create_dir_all(&prefab_dir).unwrap();

            // Create test prefab files
            let prefab1_path = prefab_dir.join("player.ron");
            let prefab2_path = prefab_dir.join("enemy.ron");

            let prefab_content = r#"
                RonPrefab(
                    components: [
                        RonComponent(
                            component_type: "Health",
                            data: Number(100.0)
                        )
                    ]
                )
            "#;

            fs::write(&prefab1_path, prefab_content).unwrap();
            fs::write(&prefab2_path, prefab_content).unwrap();

            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: format!("{}/*.ron", prefab_dir.display()),
                hot_reload: false,
            };

            let loaded_count = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count, 2);
            assert_eq!(factory.len(), 2);
        }

        #[rstest]
        fn test_load_directory_with_tilde_expansion() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs");
            fs::create_dir_all(&prefab_dir).unwrap();

            // Create test prefab file
            let prefab_path = prefab_dir.join("test.ron");
            let prefab_content = r#"
                RonPrefab(
                    components: [
                        RonComponent(
                            component_type: "Health",
                            data: Number(50.0)
                        )
                    ]
                )
            "#;
            fs::write(&prefab_path, prefab_content).unwrap();

            let mut factory = Factory::new();

            // Use an absolute path (avoiding tilde for test consistency)
            let settings = FactorySettings {
                prefab_path: format!("{}/*.ron", prefab_dir.display()),
                hot_reload: true, // Test hot_reload flag
            };

            let loaded_count = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count, 1);
            assert_eq!(factory.len(), 1);
        }

        #[rstest]
        fn test_load_directory_nonexistent_directory() {
            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: "/nonexistent/path/*.ron".to_string(),
                hot_reload: false,
            };

            let result = factory.load_directory(&settings);
            assert!(result.is_err());
            assert!(result.unwrap_err().to_string().contains("does not exist"));
        }

        #[rstest]
        fn test_load_directory_no_matching_files() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs");
            fs::create_dir_all(&prefab_dir).unwrap();

            // Create a non-matching file
            let non_matching_path = prefab_dir.join("data.txt");
            fs::write(&non_matching_path, "not a ron file").unwrap();

            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: format!("{}/*.ron", prefab_dir.display()),
                hot_reload: false,
            };

            let loaded_count = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count, 0);
            assert_eq!(factory.len(), 0);
        }

        #[rstest]
        fn test_load_directory_invalid_ron_file() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs");
            fs::create_dir_all(&prefab_dir).unwrap();

            // Create valid and invalid prefab files
            let valid_prefab = prefab_dir.join("valid.ron");
            let invalid_prefab = prefab_dir.join("invalid.ron");

            let valid_content = r#"
                RonPrefab(
                    components: [
                        RonComponent(
                            component_type: "Health",
                            data: Number(100.0)
                        )
                    ]
                )
            "#;

            fs::write(&valid_prefab, valid_content).unwrap();
            fs::write(&invalid_prefab, "invalid ron content").unwrap();

            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: format!("{}/*.ron", prefab_dir.display()),
                hot_reload: false,
            };

            // Should load the valid file and warn about the invalid one
            let loaded_count = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count, 1);
            assert_eq!(factory.len(), 1);
        }

        #[rstest]
        fn test_load_directory_all_files_invalid() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs");
            fs::create_dir_all(&prefab_dir).unwrap();

            // Create only invalid prefab files
            let invalid_prefab1 = prefab_dir.join("invalid1.ron");
            let invalid_prefab2 = prefab_dir.join("invalid2.ron");

            fs::write(&invalid_prefab1, "invalid ron content").unwrap();
            fs::write(&invalid_prefab2, "also invalid").unwrap();

            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: format!("{}/*.ron", prefab_dir.display()),
                hot_reload: false,
            };

            // Should return error when all files are invalid
            let result = factory.load_directory(&settings);
            assert!(result.is_err());
            assert_eq!(factory.len(), 0);
        }

        #[rstest]
        fn test_load_directory_glob_pattern_recursive() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs");
            let subdir = prefab_dir.join("subdir");
            fs::create_dir_all(&subdir).unwrap();

            // Create prefab files in main directory and subdirectory
            let main_prefab = prefab_dir.join("main.ron");
            let sub_prefab = subdir.join("sub.ron");

            let prefab_content = r#"
                RonPrefab(
                    components: [
                        RonComponent(
                            component_type: "Health",
                            data: Number(100.0)
                        )
                    ]
                )
            "#;

            fs::write(&main_prefab, prefab_content).unwrap();
            fs::write(&sub_prefab, prefab_content).unwrap();

            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: format!("{}/**/*.ron", prefab_dir.display()),
                hot_reload: false,
            };

            let loaded_count = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count, 2);
            assert_eq!(factory.len(), 2);
        }

        #[rstest]
        fn test_load_directory_empty_directory() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs");
            fs::create_dir_all(&prefab_dir).unwrap();

            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: format!("{}/*.ron", prefab_dir.display()),
                hot_reload: false,
            };

            let loaded_count = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count, 0);
            assert_eq!(factory.len(), 0);
        }

        #[rstest]
        fn test_generate_prefab_id_from_path() {
            let factory = Factory::new();
            let path1 = std::path::Path::new("/test/player.ron");
            let path2 = std::path::Path::new("/test/enemy.ron");
            let path3 = std::path::Path::new("/other/player.ron");

            let id1 = factory.generate_prefab_id_from_path(path1).unwrap();
            let id2 = factory.generate_prefab_id_from_path(path2).unwrap();
            let id3 = factory.generate_prefab_id_from_path(path3).unwrap();

            // IDs should be different for different filenames
            assert_ne!(id1, id2);

            // IDs should be the same for same filename (regardless of directory)
            assert_eq!(id1, id3);
        }

        #[rstest]
        fn test_generate_prefab_id_from_invalid_path() {
            let factory = Factory::new();
            let path = std::path::Path::new("/");

            let result = factory.generate_prefab_id_from_path(path);
            assert!(result.is_err());
        }

        #[rstest]
        fn test_load_prefab_file_success() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_path = temp_dir.path().join("test.ron");

            let prefab_content = r#"
                RonPrefab(
                    components: [
                        RonComponent(
                            component_type: "Health",
                            data: Number(100.0)
                        )
                    ]
                )
            "#;

            fs::write(&prefab_path, prefab_content).unwrap();

            let factory = Factory::new();
            let prefab = factory.load_prefab_file(&prefab_path).unwrap();
            assert_eq!(prefab.len(), 1);
        }

        #[rstest]
        fn test_load_prefab_file_not_found() {
            let factory = Factory::new();
            let path = std::path::Path::new("/nonexistent/file.ron");

            let result = factory.load_prefab_file(path);
            assert!(result.is_err());
        }

        #[rstest]
        fn test_load_prefab_file_invalid_ron() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_path = temp_dir.path().join("invalid.ron");

            fs::write(&prefab_path, "invalid ron content").unwrap();

            let factory = Factory::new();
            let result = factory.load_prefab_file(&prefab_path);
            assert!(result.is_err());
        }

        #[rstest]
        fn test_load_directory_with_special_characters() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs with spaces");
            fs::create_dir_all(&prefab_dir).unwrap();

            // Create test prefab file with special characters in filename
            let prefab_path = prefab_dir.join("test-file_123.ron");
            let prefab_content = r#"
                RonPrefab(
                    components: [
                        RonComponent(
                            component_type: "Health",
                            data: Number(100.0)
                        )
                    ]
                )
            "#;

            fs::write(&prefab_path, prefab_content).unwrap();

            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: format!("{}/*.ron", prefab_dir.display()),
                hot_reload: false,
            };

            let loaded_count = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count, 1);
            assert_eq!(factory.len(), 1);
        }

        #[rstest]
        fn test_load_directory_multiple_calls() {
            let temp_dir = TempDir::new().unwrap();
            let prefab_dir = temp_dir.path().join("prefabs");
            fs::create_dir_all(&prefab_dir).unwrap();

            // Create initial prefab file
            let prefab1_path = prefab_dir.join("initial.ron");
            let prefab_content = r#"
                RonPrefab(
                    components: [
                        RonComponent(
                            component_type: "Health",
                            data: Number(100.0)
                        )
                    ]
                )
            "#;

            fs::write(&prefab1_path, prefab_content).unwrap();

            let mut factory = Factory::new();
            let settings = FactorySettings {
                prefab_path: format!("{}/*.ron", prefab_dir.display()),
                hot_reload: false,
            };

            // First load
            let loaded_count1 = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count1, 1);
            assert_eq!(factory.len(), 1);

            // Add another file and load again
            let prefab2_path = prefab_dir.join("additional.ron");
            fs::write(&prefab2_path, prefab_content).unwrap();

            let loaded_count2 = factory.load_directory(&settings).unwrap();
            assert_eq!(loaded_count2, 2);
            // Should replace the first prefab and add the second
            assert_eq!(factory.len(), 2);
        }
    }
}
