use bevy::prelude::*;
use rand::Rng;
use std::cell::RefCell;
use crate::components::*;
use crate::bundles::VisibleChildBundle;
use crate::systems::world::unified_world::{
    UnifiedWorldManager, UnifiedChunkEntity, ContentLayer, ChunkCoord, ChunkState,
    UNIFIED_CHUNK_SIZE,
};
use crate::systems::world::road_network::{RoadNetwork, RoadSpline, RoadType};
use crate::systems::world::road_mesh::{generate_road_mesh, generate_road_markings_mesh};

thread_local! {
    static LAYERED_RNG: RefCell<rand::rngs::ThreadRng> = RefCell::new(rand::thread_rng());
}

// LAYERED CONTENT GENERATION SYSTEMS
// These systems generate content in layers: Roads -> Buildings -> Vehicles -> Vegetation
// Each layer waits for previous layers to complete before starting

/// System that manages the progression through content generation layers
pub fn layered_generation_coordinator(
    mut world_manager: ResMut<UnifiedWorldManager>,
    _chunk_query: Query<(Entity, &UnifiedChunkEntity)>,
    time: Res<Time>,
) {
    let current_time = time.elapsed_secs();
    
    // Process chunks that are in loading state
    let mut chunks_to_update = Vec::new();
    
    for (chunk_coord, chunk) in &world_manager.chunks {
        if matches!(chunk.state, ChunkState::Loading) {
            // Check if enough time has passed since last update (prevent frame drops)
            if current_time - chunk.last_update > 0.1 {
                chunks_to_update.push(*chunk_coord);
            }
        }
    }
    
    // Update chunk generation progress
    for coord in chunks_to_update {
        advance_chunk_generation(&mut world_manager, coord, current_time);
    }
}

fn advance_chunk_generation(
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    current_time: f32,
) {
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.last_update = current_time;
    
    // Determine what layer to generate next
    let next_layer = if !chunk.roads_generated {
        Some(ContentLayer::Roads)
    } else if !chunk.buildings_generated {
        Some(ContentLayer::Buildings)
    } else if !chunk.vehicles_generated {
        Some(ContentLayer::Vehicles)
    } else if !chunk.vegetation_generated {
        Some(ContentLayer::Vegetation)
    } else {
        // All layers complete - need to calculate LOD separately to avoid borrow issues
        let distance = chunk.distance_to_player;
        // Store distance first, then calculate LOD
        let _ = chunk; // Release the mutable borrow
        let lod_level = world_manager.calculate_lod_level(distance);
        let chunk = world_manager.get_chunk_mut(coord); // Re-borrow
        chunk.state = ChunkState::Loaded { lod_level };
        None
    };
    
    // Mark the appropriate layer flag for the generation systems to pick up
    match next_layer {
        Some(ContentLayer::Roads) => {
            // Roads will be generated by road_layer_system
        }
        Some(ContentLayer::Buildings) => {
            // Buildings will be generated by building_layer_system
        }
        Some(ContentLayer::Vehicles) => {
            // Vehicles will be generated by vehicle_layer_system
        }
        Some(ContentLayer::Vegetation) => {
            // Vegetation will be generated by vegetation_layer_system
        }
        None => {
            // Chunk generation complete
        }
        _ => {}
    }
}

/// Layer 1: Road Generation System
pub fn road_layer_system(
    mut commands: Commands,
    mut world_manager: ResMut<UnifiedWorldManager>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let chunks_to_process: Vec<ChunkCoord> = world_manager
        .chunks
        .iter()
        .filter_map(|(coord, chunk)| {
            if matches!(chunk.state, ChunkState::Loading) && !chunk.roads_generated {
                Some(*coord)
            } else {
                None
            }
        })
        .collect();
    
    for coord in chunks_to_process {
        generate_roads_for_chunk(&mut commands, &mut world_manager, coord, &mut meshes, &mut materials);
    }
}

fn generate_roads_for_chunk(
    commands: &mut Commands,
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) {
    // Use existing road network generation logic but adapted for unified system
    let new_road_ids = world_manager.road_network.generate_chunk_roads(coord.x, coord.z);
    
    // Create road entities and add to placement grid
    for road_id in new_road_ids {
        if let Some(road) = world_manager.road_network.roads.get(&road_id).cloned() {
            let road_entity = spawn_unified_road_entity(
                commands,
                coord,
                road_id,
                &road,
                meshes,
                materials,
            );
            
            // Add road to placement grid
            let samples = 20;
            for i in 0..samples {
                let t = i as f32 / (samples - 1) as f32;
                let road_point = road.evaluate(t);
                world_manager.placement_grid.add_entity(
                    road_point,
                    ContentType::Road,
                    road.road_type.width() * 0.5,
                );
            }
            
            // Add entity to chunk
            let chunk = world_manager.get_chunk_mut(coord);
            chunk.entities.push(road_entity);
        }
    }
    
    // Mark roads as generated
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.roads_generated = true;
}

fn spawn_unified_road_entity(
    commands: &mut Commands,
    chunk_coord: ChunkCoord,
    road_id: u32,
    road: &RoadSpline,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) -> Entity {
    let center_pos = road.evaluate(0.5);
    
    let road_material = create_road_material(&road.road_type, materials);
    let marking_material = create_marking_material(materials);
    
    let road_entity = commands.spawn((
        UnifiedChunkEntity {
            coord: chunk_coord,
            layer: ContentLayer::Roads,
        },
        RoadEntity { road_id },
        Transform::from_translation(center_pos),
        GlobalTransform::default(),
        Visibility::default(),
        InheritedVisibility::VISIBLE,
        ViewVisibility::default(),
        DynamicContent {
            content_type: ContentType::Road,
        },
    )).id();
    
    // Road surface mesh
    let road_mesh = generate_road_mesh(road);
    commands.spawn((
        Mesh3d(meshes.add(road_mesh)),
        MeshMaterial3d(road_material),
        Transform::from_translation(-center_pos),
        ChildOf(road_entity),
        VisibleChildBundle::default(),
    ));
    
    // Road markings
    let marking_meshes = generate_road_markings_mesh(road);
    for marking_mesh in marking_meshes {
        commands.spawn((
            Mesh3d(meshes.add(marking_mesh)),
            MeshMaterial3d(marking_material.clone()),
            Transform::from_translation(-center_pos + Vec3::new(0.0, 0.01, 0.0)),
            ChildOf(road_entity),
            VisibleChildBundle::default(),
        ));
    }
    
    road_entity
}

/// Layer 2: Building Generation System
pub fn building_layer_system(
    mut commands: Commands,
    mut world_manager: ResMut<UnifiedWorldManager>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let chunks_to_process: Vec<ChunkCoord> = world_manager
        .chunks
        .iter()
        .filter_map(|(coord, chunk)| {
            if matches!(chunk.state, ChunkState::Loading) 
                && chunk.roads_generated 
                && !chunk.buildings_generated {
                Some(*coord)
            } else {
                None
            }
        })
        .collect();
    
    for coord in chunks_to_process {
        generate_buildings_for_chunk(&mut commands, &mut world_manager, coord, &mut meshes, &mut materials);
    }
}

fn generate_buildings_for_chunk(
    commands: &mut Commands,
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) {
    let chunk_center = coord.to_world_pos();
    let half_size = UNIFIED_CHUNK_SIZE * 0.5;
    
    // Determine building density based on distance from center
    let distance_from_center = Vec2::new(chunk_center.x, chunk_center.z).length();
    let building_density = (1.0 - (distance_from_center / 2000.0).min(0.8)).max(0.1);
    
    // Generate building positions
    let building_attempts = (building_density * 20.0) as usize;
    
    for _ in 0..building_attempts {
        let local_x = LAYERED_RNG.with(|rng| rng.borrow_mut().gen_range(-half_size..half_size));
        let local_z = LAYERED_RNG.with(|rng| rng.borrow_mut().gen_range(-half_size..half_size));
        let position = Vec3::new(chunk_center.x + local_x, 0.0, chunk_center.z + local_z);
        
        // Check if position is valid (not on road, not overlapping other buildings)
        if !is_on_road_unified(position, &world_manager.road_network) {
            let building_size = LAYERED_RNG.with(|rng| rng.borrow_mut().gen_range(8.0..15.0));
            if world_manager.placement_grid.can_place(
                position,
                ContentType::Building,
                building_size * 0.5,
                building_size,
            ) {
                let building_entity = spawn_unified_building(
                    commands,
                    coord,
                    position,
                    distance_from_center,
                    meshes,
                    materials,
                );
                
                // Add to placement grid
                world_manager.placement_grid.add_entity(
                    position,
                    ContentType::Building,
                    building_size * 0.5,
                );
                
                // Add entity to chunk
                let chunk = world_manager.get_chunk_mut(coord);
                chunk.entities.push(building_entity);
            }
        }
    }
    
    // Mark buildings as generated
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.buildings_generated = true;
}

fn spawn_unified_building(
    commands: &mut Commands,
    chunk_coord: ChunkCoord,
    position: Vec3,
    _distance_from_center: f32,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) -> Entity {
    // REPLACED: Use UnifiedEntityFactory for building spawning
    // This eliminates duplicate building spawning code
    use crate::factories::entity_factory_unified::UnifiedEntityFactory;
    use crate::GameConfig;
    
    let mut factory = UnifiedEntityFactory::with_config(GameConfig::default());
    let current_time = 0.0; // Placeholder time
    
    match factory.spawn_building_consolidated(commands, meshes, materials, position, current_time) {
        Ok(entity) => {
            // Add chunk-specific components to maintain compatibility
            commands.entity(entity).insert((
                UnifiedChunkEntity {
                    coord: chunk_coord,
                    layer: ContentLayer::Buildings,
                },
            ));
            entity
        }
        Err(_) => {
            // Fallback to empty entity if spawn fails
            commands.spawn((
                Transform::from_translation(position),
                Visibility::Hidden,
            )).id()
        }
    }
}

/// Layer 3: Vehicle Generation System
pub fn vehicle_layer_system(
    mut commands: Commands,
    mut world_manager: ResMut<UnifiedWorldManager>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let chunks_to_process: Vec<ChunkCoord> = world_manager
        .chunks
        .iter()
        .filter_map(|(coord, chunk)| {
            if matches!(chunk.state, ChunkState::Loading) 
                && chunk.buildings_generated 
                && !chunk.vehicles_generated {
                Some(*coord)
            } else {
                None
            }
        })
        .collect();
    
    for coord in chunks_to_process {
        generate_vehicles_for_chunk(&mut commands, &mut world_manager, coord, &mut meshes, &mut materials);
    }
}

fn generate_vehicles_for_chunk(
    commands: &mut Commands,
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) {
    let chunk_center = coord.to_world_pos();
    let half_size = UNIFIED_CHUNK_SIZE * 0.5;
    
    // Generate vehicles only on roads
    let vehicle_attempts = 5; // Conservative number to prevent overcrowding
    
    for _ in 0..vehicle_attempts {
        let local_x = LAYERED_RNG.with(|rng| rng.borrow_mut().gen_range(-half_size..half_size));
        let local_z = LAYERED_RNG.with(|rng| rng.borrow_mut().gen_range(-half_size..half_size));
        let position = Vec3::new(chunk_center.x + local_x, 0.0, chunk_center.z + local_z);
        
        // Only spawn on roads with sufficient spacing
        if is_on_road_unified(position, &world_manager.road_network) {
            if world_manager.placement_grid.can_place(
                position,
                ContentType::Vehicle,
                4.0, // Vehicle radius
                25.0, // Minimum distance between vehicles
            ) {
                let vehicle_entity = spawn_unified_vehicle(
                    commands,
                    coord,
                    position,
                    meshes,
                    materials,
                );
                
                // Add to placement grid
                world_manager.placement_grid.add_entity(
                    position,
                    ContentType::Vehicle,
                    4.0,
                );
                
                // Add entity to chunk
                let chunk = world_manager.get_chunk_mut(coord);
                chunk.entities.push(vehicle_entity);
            }
        }
    }
    
    // Mark vehicles as generated
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.vehicles_generated = true;
}

fn spawn_unified_vehicle(
    commands: &mut Commands,
    chunk_coord: ChunkCoord,
    position: Vec3,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) -> Entity {
    // REPLACED: Use UnifiedEntityFactory for vehicle spawning
    // This eliminates duplicate vehicle spawning code
    use crate::factories::entity_factory_unified::UnifiedEntityFactory;
    use crate::GameConfig;
    
    let mut factory = UnifiedEntityFactory::with_config(GameConfig::default());
    let current_time = 0.0; // Placeholder time
    
    match factory.spawn_vehicle_consolidated(commands, meshes, materials, position, current_time) {
        Ok(entity) => {
            // Add chunk-specific components to maintain compatibility
            commands.entity(entity).insert((
                UnifiedChunkEntity {
                    coord: chunk_coord,
                    layer: ContentLayer::Vehicles,
                },
            ));
            entity
        }
        Err(_) => {
            // Fallback to empty entity if spawn fails
            commands.spawn((
                Transform::from_translation(position),
                Visibility::Hidden,
            )).id()
        }
    }
}

/// Layer 4: Vegetation Generation System
pub fn vegetation_layer_system(
    mut commands: Commands,
    mut world_manager: ResMut<UnifiedWorldManager>,
    mut meshes: ResMut<Assets<Mesh>>,
    mut materials: ResMut<Assets<StandardMaterial>>,
) {
    let chunks_to_process: Vec<ChunkCoord> = world_manager
        .chunks
        .iter()
        .filter_map(|(coord, chunk)| {
            if matches!(chunk.state, ChunkState::Loading) 
                && chunk.vehicles_generated 
                && !chunk.vegetation_generated {
                Some(*coord)
            } else {
                None
            }
        })
        .collect();
    
    for coord in chunks_to_process {
        generate_vegetation_for_chunk(&mut commands, &mut world_manager, coord, &mut meshes, &mut materials);
    }
}

fn generate_vegetation_for_chunk(
    commands: &mut Commands,
    world_manager: &mut UnifiedWorldManager,
    coord: ChunkCoord,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) {
    let chunk_center = coord.to_world_pos();
    let half_size = UNIFIED_CHUNK_SIZE * 0.5;
    
    // Generate trees and vegetation in open areas
    let vegetation_attempts = 8;
    
    for _ in 0..vegetation_attempts {
        let local_x = LAYERED_RNG.with(|rng| rng.borrow_mut().gen_range(-half_size..half_size));
        let local_z = LAYERED_RNG.with(|rng| rng.borrow_mut().gen_range(-half_size..half_size));
        let position = Vec3::new(chunk_center.x + local_x, 0.0, chunk_center.z + local_z);
        
        // Only spawn vegetation away from roads and buildings
        if !is_on_road_unified(position, &world_manager.road_network) {
            if world_manager.placement_grid.can_place(
                position,
                ContentType::Tree,
                2.0, // Tree radius
                8.0, // Minimum distance between trees
            ) {
                let tree_entity = spawn_unified_tree(
                    commands,
                    coord,
                    position,
                    meshes,
                    materials,
                );
                
                // Add to placement grid
                world_manager.placement_grid.add_entity(
                    position,
                    ContentType::Tree,
                    2.0,
                );
                
                // Add entity to chunk
                let chunk = world_manager.get_chunk_mut(coord);
                chunk.entities.push(tree_entity);
            }
        }
    }
    
    // Mark vegetation as generated
    let chunk = world_manager.get_chunk_mut(coord);
    chunk.vegetation_generated = true;
}

fn spawn_unified_tree(
    commands: &mut Commands,
    chunk_coord: ChunkCoord,
    position: Vec3,
    meshes: &mut ResMut<Assets<Mesh>>,
    materials: &mut ResMut<Assets<StandardMaterial>>,
) -> Entity {
    // REPLACED: Use UnifiedEntityFactory for tree spawning
    // This eliminates duplicate tree spawning code
    use crate::factories::entity_factory_unified::UnifiedEntityFactory;
    use crate::GameConfig;
    
    let mut factory = UnifiedEntityFactory::with_config(GameConfig::default());
    let current_time = 0.0; // Placeholder time
    
    match factory.spawn_tree_consolidated(commands, meshes, materials, position, current_time) {
        Ok(entity) => {
            // Add chunk-specific components to maintain compatibility
            commands.entity(entity).insert((
                UnifiedChunkEntity {
                    coord: chunk_coord,
                    layer: ContentLayer::Vegetation,
                },
            ));
            entity
        }
        Err(_) => {
            // Fallback to empty entity if spawn fails
            commands.spawn((
                Transform::from_translation(position),
                Visibility::Hidden,
            )).id()
        }
    }
}

// Utility functions

fn is_on_road_unified(position: Vec3, road_network: &RoadNetwork) -> bool {
    for road in road_network.roads.values() {
        if is_point_on_road_spline_unified(position, road, 25.0) {
            return true;
        }
    }
    false
}

fn is_point_on_road_spline_unified(position: Vec3, road: &RoadSpline, tolerance: f32) -> bool {
    let samples = 20; // Reduced samples for performance
    let width = road.road_type.width();
    
    for i in 0..samples {
        let t = i as f32 / (samples - 1) as f32;
        let road_point = road.evaluate(t);
        let distance = Vec3::new(position.x - road_point.x, 0.0, position.z - road_point.z).length();
        
        if distance <= width * 0.5 + tolerance {
            return true;
        }
    }
    
    false
}

fn create_road_material(road_type: &RoadType, materials: &mut ResMut<Assets<StandardMaterial>>) -> Handle<StandardMaterial> {
    let (base_color, roughness) = match road_type {
        RoadType::Highway => (Color::srgb(0.4, 0.4, 0.45), 0.8),
        RoadType::MainStreet => (Color::srgb(0.35, 0.35, 0.4), 0.8),
        RoadType::SideStreet => (Color::srgb(0.45, 0.45, 0.5), 0.7),
        RoadType::Alley => (Color::srgb(0.5, 0.5, 0.45), 0.6),
    };
    
    materials.add(StandardMaterial {
        base_color,
        perceptual_roughness: roughness,
        metallic: 0.0,
        reflectance: 0.2,
        emissive: Color::BLACK.into(),
        ..default()
    })
}

fn create_marking_material(materials: &mut ResMut<Assets<StandardMaterial>>) -> Handle<StandardMaterial> {
    materials.add(StandardMaterial {
        base_color: Color::srgb(0.95, 0.95, 0.95),
        emissive: LinearRgba::new(0.2, 0.2, 0.2, 1.0),
        perceptual_roughness: 0.6,
        metallic: 0.0,
        reflectance: 0.5,
        ..default()
    })
}


